# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PhotoPhlyDockWidget
                                 A QGIS plugin
 Drone 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Lukas Winiwarter
        email                : lukas.winiwarter@uni-heidelberg.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

import urllib.request
import json

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QTimer
from qgis.gui import QgsRubberBand
from qgis.core import QgsGeometry, QgsPoint, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject
from qgis.utils import iface

import numpy as np

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'photo_phly_dockwidget_base.ui'))


class PhotoPhlyDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(PhotoPhlyDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        canvas = iface.mapCanvas()
        self.hist = []
        self.rubberBand = QgsRubberBand(canvas, False)
        self.rubberBand.setWidth(5)
        self.rubberBand.setColor(QtGui.QColor(255, 0, 0))
        self.getTimer = QTimer()
        self.getTimer.timeout.connect(self.getState)
        self.getTimer.setInterval(100)
        self.setTimer = QTimer()
        self.setTimer.timeout.connect(self.sendCommand)
        self.setTimer.setInterval(100)
        self.photoTimeCount = 0
        self.btnConnect.clicked.connect(self.connection)
        self.btnStart.clicked.connect(self.startAutopilot)
        self.btnStop.clicked.connect(lambda: self.sendCommand(stop=True))
        self.btnClearTrace.clicked.connect(self.hist.clear)
        self.pushButton_3.clicked.connect(self.skip)
        self.wp = []
        self.currentWP = 0
        self.pos = QgsPoint()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
        self.getTimer.stop()
        iface.mapCanvas().scene().removeItem(self.rubberBand)

    def connection(self, event):
        if self.getTimer.isActive():
            self.getTimer.stop()
            self.btnConnect.setText("Connect")
        else:
            self.getTimer.start()
            self.btnConnect.setText("Connecting...")


    def getState(self):
        try:
            with urllib.request.urlopen(f'http://{self.txtIPAddr.text()}:9000/cgi/getState') as response:
                resp = response.read()
                data = json.loads(resp)
            self.txtLat.setText(str(data['lat']) + "°")
            self.txtLon.setText(str(data['lon']) + "°")
            self.txtHeight.setText(str(data['height']) + " m")
            point = QgsPoint(data['lon'], data['lat'])
            crs = QgsCoordinateReferenceSystem(4326)
            self.hist.append(point)
            if self.chkTrace.isChecked():
                self.rubberBand.setToGeometry(QgsGeometry.fromPolyline(self.hist),
                                              crs=crs)
            else:
                self.rubberBand.setToGeometry(QgsGeometry())

            xform = QgsCoordinateTransform(crs, self.flightLayer.currentLayer().sourceCrs(), QgsProject.instance())
            self.pos = point.clone()
            self.pos.transform(xform)
            if len(self.wp) > 0:
                if self.pos.distance(self.wp[self.currentWP]) < 0.5 and abs(data['height'] - self.dblAlt.value() + self.dblOffset.value()) < 0.5:
                    self.currentWP += 1
                    if self.currentWP == len(self.wp):
                        self.progressBar.setValue(100)
                        self.sendCommand(stop=True)

            self.btnConnect.setText("Connected")
        except Exception as e:
            print(e)
            self.btnConnect.setText("Connect")
            self.getTimer.stop()
    def skip(self):
        self.currentWP += 1

    def startAutopilot(self):
        lay = self.flightLayer.currentLayer()
        #feats = lay.featureCount()
        #geom = lay.getGeometry(0)
        #featReq = self.flightFeature.currentFeatureRequest()
        #featID = featReq.filterFid()
        #print(featID)
        geom = lay.getGeometry(0).constGet()
        if geom.hasChildGeometries():
            geom = geom.childGeometry(0)
        self.wp = []
        self.currentWP = 0
        for ptId in range(geom.numPoints()):
            pt = geom[ptId]
            self.wp.append(pt)
        self.setTimer.start()

    def sendCommand(self, stop=False):
        self.photoTimeCount += 1
        if self.photoTimeCount >= self.dblInterval.value() * 10 and self.currentWP > 0:
            print("Taking photo")
            req = urllib.request.Request(f'http://{self.txtIPAddr.text()}:9000/cgi/takePhoto',
                                         method="PUT")
            resp = urllib.request.urlopen(req)
            self.photoTimeCount = 0
        if stop:
            self.setTimer.stop()
            rp = [0,0]
            yaw = 0
            throttle = float("0" + self.txtHeight.text().split(" ")[0])
            self.lblStatus.setText(f"Status: Stopped")
        else:
            self.progressBar.setValue(100*self.currentWP/len(self.wp))
            roll = self.wp[self.currentWP].x() - self.pos.x()  # delta x
            pitch = self.wp[self.currentWP].y() - self.pos.y()  # delta y
            rp = np.array([roll, pitch])
            rp *= 1/np.linalg.norm(rp) * min(self.dblSpeed.value(), self.pos.distance(self.wp[self.currentWP])/4)
            yaw = self.pos.azimuth(self.wp[self.currentWP])# deg
            throttle = self.dblAlt.value() # m
        #print(rp[0], rp[1], yaw, throttle)
        data = urllib.parse.urlencode({
            'pitch': rp[0],
            'roll': rp[1],
            'yaw': yaw,
            'throttle': throttle
        }).encode()
        req = urllib.request.Request(f'http://{self.txtIPAddr.text()}:9000/cgi/setState', data=data)  # this will make the method "POST"
        resp = urllib.request.urlopen(req)
        self.lblStatus.setText(f"Status: Heading to WP {self.currentWP}")